:spring_boot_version: 2.0.5.RELEASE
:SpringApplication: http://docs.spring.io/spring-boot/docs/{spring_boot_version}/api/org/springframework/boot/SpringApplication.html
:toc:
:icons: font
:source-highlighter: prettify
:project_id: gs-reactive-rest-service

This guide walks you through the process of creating a "Hello, Spring!" RESTful web
service with Spring WebFlux (new as of version 5) and then consumes that service with a
WebClient (also new as of version 5).

NOTE: This guide shows the functional way of using Spring WebFlux. You can also
http://aLinkToSomething[use annotations with WebFlux].

== What You'll Build

Youâ€™ll build a RESTful web service with Spring Webflux and a WebClient consumer of that
service. You'll be able to see output in both System.out and at:

[source]
http://localhost:8080/hello

== What You'll Need

:java_version: 1.8
include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/prereq_editor_jdk_buildtools.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/how_to_complete_this_guide.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-gradle.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-maven.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-sts.adoc[]

[[initial]]
== Create a WebFlux Handler

In the Spring Reactive approach, we use a handler to handle the request and create a
response, as shown in the following example:

`src/main/java/hello/GreetingHandler.java`
[source,java]
----
include::complete/src/main/java/hello/GreetingHandler.java[]
----

This simple reactive class always returns "Hello, Spring!" It could return many other
things, including a stream of items from a database, a stream of items that were
generated by calculations, and so on. Note the reactive code: a `Mono` object that holds
a `ServerResponse` body.

== Create a Router

In this application, we use a router to handle the only route we expose ("/hello"), as
shown in the following example:

`src/main/java/hello/GreetingRouter.java`
[source,java]
----
include::complete/src/main/java/hello/GreetingRouter.java[]
----

The router listens for traffic on the `/hello` path and returns the value provided by our
reactive handler class.

== Create a WebClient

The Spring MVC RestTemplate class is, by nature, blocking. Consequently, we don't
want to use it in a reactive application. For reactive applications, Spring offers the
WebClient class, which is non-blocking. We'll use a WebClient implementation
to consume our RESTful service:

`src/main/java/hello/GreetingWebClient.java`
[source,java]
----
include::complete/src/main/java/hello/GreetingWebClient.java[]
----

The WebClient uses reactive features, in the form of a Mono to hold the content of the URI
we specify and a function (in the `getResult` method) to turn that content into a string.
If we had different requirements, we might turn it into something other than a string.
Since we're going to put the result into System.out, a string will do here.

TIP: WebClient can be used to communicate with non-reactive, blocking services, too.

== Make the Application Executable

Although it is possible to package this service as a traditional
link:/understanding/WAR[WAR] file for deployment to an external application server,
the simpler approach demonstrated below creates a standalone application. You package
everything in a single, executable JAR file, driven by a good old Java `main()` method.
Along the way, you use Reactive Spring's support for embedding the Netty server as the
HTTP runtime, instead of deploying to an external instance.

`src/main/java/hello/Application.java`
[source,java]
----
include::complete/src/main/java/hello/Application.java[]
----

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/spring-boot-application.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/build_an_executable_jar_subhead.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/build_an_executable_jar_with_both.adoc[]

Logging output is displayed. The service should be up and running within a few seconds.

Once the service has started, you'll see a line that reads:

`>> result = Hello, Spring!`

That line comes from the reactive content being consumed by the WebClient. Naturally,
you can find something more interesting to do with your output than put it in System.out.

== Test the Application

Now that the application is running, you can test it. To start with, you can open a
browser and go to `http://localhost:8080/hello` and see, "Hello, Spring!" For this guide,
we also created a test class to get you started on testing with the WebTestClient class.

`src/test/java/hello/GreetingRouterTest.java`
[source,java]
----
include::complete/src/test/java/hello/GreetingRouterTest.java[]
----

== Summary

Congratulations! You have developed a Reactive Spring application that includes a
WebClient to consume a RESTful service!

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/footer.adoc[]
